= Android Developer Security Guide

This is a summary of the https://developer.android.com/training/best-security.html[Android Developer Security Guide].

== Overview
The following core security features help you build secure apps:

* The Android Application Sandbox, which isolates your app data and code execution from other apps.
* An application framework with robust implementations of common security functionality such as cryptography, permissions, and secure IPC.
* Technologies like ASLR, NX, ProPolice, safe_iop, OpenBSD dlmalloc, OpenBSD calloc, and Linux mmap_min_addr to mitigate risks associated with common memory management errors.
* An encrypted file system that can be enabled to protect data on lost or stolen devices.
* User-granted permissions to restrict access to system features and user data.
* Application-defined permissions to control application data on a per-app basis.

== Data Storage

The most common security concern for an application on Android is whether the data that you save on the device is accessible to other apps.

There are three fundamental ways to save data on the device:

. *Internal Storage*
.. By default, files that you create on internal storage are accessible only to your app. Android implements this protection, and it's sufficient for most applications.
.. Avoid the `MODE_WORLD_WRITEABLE` or `MODE_WORLD_READABLE` modes for IPC files because they do not provide the ability to limit data access to particular applications, nor do they provide any control of data format. If you want to share your data with other app processes, instead consider using a content provider, which offers read and write permissions to other apps and can make dynamic permission grants on a case-by-case basis.

. *External Storage*
.. Files created on external storage, such as SD cards, are globally readable and writable. Because external storage can be removed by the user and also modified by any application, don't store sensitive information using external storage.
.. You should Perform input validation when handling data from external storage as you would with data from any untrusted source. You should not store executables or class files on external storage prior to dynamic loading. If your app does retrieve executable files from external storage, the files should be signed and cryptographically verified prior to dynamic loading.

. *Content Providers*
.. Content providers offer a structured storage mechanism that can be limited to your own application or exported to allow access by other applications.
If you do not intend to provide other applications with access to your ContentProvider, mark them as `android:exported=false` in the application manifest.
Otherwise, set the `android:exported` attribute to true to allow other apps to access the stored data.
.. If you are using a content provider for sharing data between only your own apps, it is preferable to use the `android:protectionLevel` attribute set to signature protection.
Signature permissions do not require user confirmation, so they provide a better user experience and more controlled access to the content provider data when the apps accessing the data are signed with the same key.

== Permissions

Android permissions are ranked in four different categories based on the protection level they offer:

. Normal: the lower level of protection. It gives the apps access to isolated application-level feature, with minimal risk to other apps, the user or the system. It is granted during the installation of the App. It is also the default value for the cases when no protection level is specified. Example: `android.permission.INTERNET`
. Dangerous: This permission usually gives the app control over the user data or over the device that impacts the user. This type of permission may not be granted at installation time, leaving it to the user to decide whether the app should have the permission or not. Example: `android.permission.RECORD_AUDIO`
. Signature: This permission is granted only if the requesting app was signed with the same certificate as the app that declared the permission. If the signature matches, the permission is automatically granted. Example: `android.permission.ACCESS_MOCK_LOCATION`
. SystemOrSignature: Permission only granted to the apps embedded in the system image or that were signed using the same certificated as the app that declared the permission. Example: `android.permission.ACCESS_DOWNLOAD_MANAGER`

== IP Networking
. You should use HTTPS over HTTP anywhere that HTTPS is supported on the server, because mobile devices frequently connect on networks that are not secured, such as public Wi-Fi hotspots.
Authenticated, encrypted socket-level communication can be easily implemented using the https://developer.android.com/reference/javax/net/ssl/SSLSocket.html[SSLSocket class].

. Some applications use localhost network ports for handling sensitive IPC.
You should not use this approach because these interfaces are accessible by other applications on the device.
Instead, use an Android IPC mechanism where authentication is possible, such as with a Service.
Binding to `INADDR_ANY` is worse than using loopback because then your application may receive requests from anywhere.

. Make sure that you don't trust data downloaded from HTTP or other insecure protocols. This includes validation of input in WebView and any responses to intents issued against HTTP.

== Telephony Networking
. Beware that SMS is neither encrypted nor strongly authenticated on either the network or the device. In particular, any SMS receiver should expect that a malicious user may have sent the SMS to your application.
Don't rely on unauthenticated SMS data to perform sensitive commands.

. Also, you should be aware that SMS may be subject to spoofing and/or interception on the network. On the Android-powered device itself, SMS messages are transmitted as broadcast intents, so they may be read or captured by other applications that have the `READ_SMS` permission.

== Input Validation
. Insufficient input validation is one of the most common security problems affecting applications, regardless of what platform they run on.
Android has platform-level countermeasures that reduce the exposure of applications to input validation issues, and you should use those features where possible.

. If you are using native code, any data read from files, received over the network, or received from an IPC has the potential to introduce a security issue. The most common problems are http://en.wikipedia.org/wiki/Buffer_overflow[buffer overflows], http://en.wikipedia.org/wiki/Double_free#Use_after_free[use after free], and http://en.wikipedia.org/wiki/Off-by-one_error[off-by-one errors].
Android provides a number of technologies like ASLR and DEP that reduce the exploitability of these errors, but they don't solve the underlying problem. You can prevent these vulnerabilities by carefully handling pointers and managing buffers.

. If you are using data within queries that are submitted to an SQL database or a content provider, SQL injection may be an issue. The best defense is to use parameterized queries, as is discussed in the above section about content providers. Limiting permissions to read-only or write-only can also reduce the potential for harm related to SQL injection.

. You should make sure to use well-structured data formats and verify that the data conforms to the expected format. While blacklisting of characters or character-replacement can be an effective strategy, these techniques are error prone in practice and should be avoided when possible.

== Handling User Data
. In general, the best approach for user data security is to minimize the use of APIs that access sensitive or personal user data. If you have access to user data and can avoid storing or transmitting it, don't store or transmit the data.

. Consider if there is a way that your application logic can be implemented using a hash or non-reversible form of the data.

. For example, your application might use the hash of an email address as a primary key to avoid transmitting or storing the email address. This reduces the chances of inadvertently exposing data, and it also reduces the chance of attackers attempting to exploit your application.

. If your app requires access to sensitive data, evaluate whether you need to transmit it to a server or you can run the operation on the client. Consider running any code using sensitive data on the client to avoid transmitting user data.

. Also, make sure that you do not inadvertently expose user data to other applications on the device through overly permissive IPC, world-writable files, or network sockets. Overly permissive IPC is a special case of leaking permission-protected data.

. If a GUID is required, create a large, unique number and store it. Don't use phone identifiers such as the phone number or IMEI, which may be associated with personal information.

. Be careful when writing to on-device logs. In Android, logs are a shared resource and are available to an application with the `READ_LOGS` permission.

== Using Webviews
. Because WebView consumes web content that can include HTML and JavaScript, improper use can introduce common web security issues such as XSS.
 Android includes a number of mechanisms to reduce the scope of these potential issues by limiting the capability of WebView to the minimum functionality required by your application

 . If your application doesn't directly use JavaScript within a WebView, do not call `setJavaScriptEnabled()`. By default, WebView does not execute JavaScript, so XSS is not possible.

 . If your application accesses sensitive data with a WebView, you may want to use the `clearCache()` method to delete any files stored locally. You can also use server-side headers such as `no-cache` to indicate that an application should not cache particular content.

. Use `addJavaScriptInterface()` with particular care because it allows JavaScript to invoke operations that are normally reserved for Android applications. If you use it, expose `addJavaScriptInterface()` only to web pages from which all input is trustworthy.
In general, the Android documentation recommends exposing `addJavaScriptInterface()` only to JavaScript that is contained within your application APK.

== Handling Credentials
. To make phishing attacks more conspicuous and less likely to be successful, minimize the frequency of asking for user credentials. Instead use an authorization token and refresh it.

. Where possible, don't store user names and passwords on the device. Instead, perform initial authentication using the user name and password supplied by the user, and then use a short-lived, service-specific authorization token.

. Services that are accessible to multiple applications should be accessed using AccountManager. If possible, use the AccountManager class to invoke a cloud-based service and don't store passwords on the device.

. After using AccountManager to retrieve an Account, use https://developer.android.com/reference/android/accounts/Account.html#CREATOR[CREATOR] before passing in any credentials so that you do not inadvertently pass credentials to the wrong application.

. If credentials are used only by applications that you create, you can verify the application that accesses the AccountManager using `checkSignature()`. Alternatively, if only one application uses the credential, you might use a KeyStore for storage.

== Cryptography

. Use a secure random number generator, SecureRandom, to initialize any cryptographic keys generated by KeyGenerator. Use of a key that is not generated with a secure random number generator significantly weakens the strength of the algorithm and may allow offline attacks.

. If you need to store a key for repeated use, use a mechanism, such as KeyStore, that provides a mechanism for long term storage and retrieval of cryptographic keys.

== IPC
. Some apps attempt to implement IPC using traditional Linux techniques such as network sockets and shared files.
However, you should instead use Android system functionality for IPC such as https://developer.android.com/reference/android/content/Intent.html[Intent], https://developer.android.com/reference/android/os/Binder.html[Binder] or https://developer.android.com/reference/android/os/Messenger.html[Messenger] with a https://developer.android.com/reference/android/app/Service.html[Service], and https://developer.android.com/reference/android/content/BroadcastReceiver.html[BroadcastReceiver].
The Android IPC mechanisms allow you to verify the identity of the application connecting to your IPC and set a security policy for each IPC mechanism.

. Many of the security elements are shared across IPC mechanisms. If your IPC mechanism is not intended for use by other applications, set the `android:exported` attribute to `false` in the component's manifest element.

. If your IPC is accessible to other applications, you can apply a security policy by using the `<permission>` element.
If IPC is between your own separate apps that are signed with the same key, it is preferable to use signature level permission in the `android:protectionLevel`.

== Intents
. For activities and broadcast receivers, intents are the preferred mechanism for asynchronous IPC in Android. Depending on your application requirements, you might use https://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)[sendBroadcast()], https://developer.android.com/reference/android/content/Context.html#sendOrderedBroadcast[sendOrderedBroadcast()], or an explicit intent to a specific application component. For security purposes, explicit intents are preferred.

. If you use an intent to bind to a Service, ensure that your app is secure by using an explicit intent. Using an implicit intent to start a service is a security hazard because you can't be certain what service will respond to the intent, and the user can't see which service starts.

. Senders of an intent can verify that the recipient has permission by specifying a non-null permission with the method call. Only applications with that permission receive the intent. If data within a broadcast intent may be sensitive, you should consider applying a permission to make sure that malicious applications can't register to receive those messages without appropriate permissions. In those circumstances, you may also consider invoking the receiver directly, rather than raising a broadcast.

== Services
A Service is often used to supply functionality for other applications to use. Each service class must have a corresponding `<service>` declaration in its manifest file.

. By default, services are not exported and cannot be invoked by any other application. However, if you add any intent filters to the service declaration, it is exported by default.
It's best if you explicitly declare the `android:exported` attribute to be sure it behaves as you'd like. Services can also be protected using the `android:permission attribute`.
By doing so, other applications need to declare a corresponding `<uses-permission>` element in their own manifest to be able to start, stop, or bind to the service.

. If your app targets Android 5.0 (API level 21) or later, you should use the https://developer.android.com/reference/android/app/job/JobScheduler.html[JobScheduler] to execute background services.

. A service can protect individual IPC calls into it with permissions, by calling `checkCallingPermission()` before executing the implementation of that call.
You should use the declarative permissions in the manifest, since those are less prone to oversight.

== Binder and Messenger Interfaces
. Using https://developer.android.com/reference/android/os/Binder.html[Binder] or https://developer.android.com/reference/android/os/Messenger.html[Messenger] is the preferred mechanism for RPC-style IPC in Android.
They provide a well-defined interface that enables mutual authentication of the endpoints, if required.

. If you are providing an interface that does require access controls, use https://developer.android.com/reference/android/content/Context.html#checkCallingPermission(java.lang.String)[checkCallingPermission()] to verify whether the caller has a required permission.
This is especially important before accessing a service on behalf of the caller, as the identify of your application is passed to other interfaces.

== Broadcast Receivers
. A BroadcastReceiver handles asynchronous requests initiated by an Intent.

. By default, receivers are exported and can be invoked by any other application. If your BroadcastReceiver is intended for use by other applications, you may want to apply security permissions to receivers using the `<receiver>` element within the application manifest.
This prevents applications without appropriate permissions from sending an intent to the BroadcastReceiver.

== Dynamically Loading Code
. Loading code from outside of your application APK significantly increases the likelihood of application compromise due to code injection or code tampering.

. If your application does dynamically load code, the most important thing to keep in mind about dynamically-loaded code is that it runs with the same security permissions as the application APK.

. The major security risk associated with dynamically loading code is that the code needs to come from a verifiable source.

== Virtual Machine Security
. Dalvik is Android's runtime virtual machine (VM). Your application runs in a secure sandbox environment, so other processes on the system can't access your code or private data.
