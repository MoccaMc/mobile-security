= Android Developer Security Guide

This is a summary of the https://developer.android.com/training/best-security.html[Android Developer Security Guide].

== Overview
The following core security features help you build secure apps:

* The Android Application Sandbox, which isolates your app data and code execution from other apps.
* An application framework with robust implementations of common security functionality such as cryptography, permissions, and secure IPC.
* Technologies like ASLR, NX, ProPolice, safe_iop, OpenBSD dlmalloc, OpenBSD calloc, and Linux mmap_min_addr to mitigate risks associated with common memory management errors.
* An encrypted file system that can be enabled to protect data on lost or stolen devices.
* User-granted permissions to restrict access to system features and user data.
* Application-defined permissions to control application data on a per-app basis.

=== Data Storage

The most common security concern for an application on Android is whether the data that you save on the device is accessible to other apps.

There are three fundamental ways to save data on the device:

. *Internal Storage*
.. By default, files that you create on internal storage are accessible only to your app. Android implements this protection, and it's sufficient for most applications.
.. Avoid the `MODE_WORLD_WRITEABLE` or `MODE_WORLD_READABLE` modes for IPC files because they do not provide the ability to limit data access to particular applications, nor do they provide any control of data format. If you want to share your data with other app processes, instead consider using a content provider, which offers read and write permissions to other apps and can make dynamic permission grants on a case-by-case basis.

. *External Storage*
.. Files created on external storage, such as SD cards, are globally readable and writable. Because external storage can be removed by the user and also modified by any application, don't store sensitive information using external storage.
.. You should Perform input validation when handling data from external storage as you would with data from any untrusted source. You should not store executables or class files on external storage prior to dynamic loading. If your app does retrieve executable files from external storage, the files should be signed and cryptographically verified prior to dynamic loading.

. *Content Providers*
.. Content providers offer a structured storage mechanism that can be limited to your own application or exported to allow access by other applications.
If you do not intend to provide other applications with access to your ContentProvider, mark them as `android:exported=false` in the application manifest.
Otherwise, set the `android:exported` attribute to true to allow other apps to access the stored data.
.. If you are using a content provider for sharing data between only your own apps, it is preferable to use the `android:protectionLevel` attribute set to signature protection.
Signature permissions do not require user confirmation, so they provide a better user experience and more controlled access to the content provider data when the apps accessing the data are signed with the same key.

=== Permissions

Android permissions are ranked in four different categories based on the protection level they offer:

. Normal: the lower level of protection. It gives the apps access to isolated application-level feature, with minimal risk to other apps, the user or the system. It is granted during the installation of the App. It is also the default value for the cases when no protection level is specified. Example: `android.permission.INTERNET`
. Dangerous: This permission usually gives the app control over the user data or over the device that impacts the user. This type of permission may not be granted at installation time, leaving it to the user to decide whether the app should have the permission or not. Example: `android.permission.RECORD_AUDIO`
. Signature: This permission is granted only if the requesting app was signed with the same certificate as the app that declared the permission. If the signature matches, the permission is automatically granted. Example: `android.permission.ACCESS_MOCK_LOCATION`
. SystemOrSignature: Permission only granted to the apps embedded in the system image or that were signed using the same certificated as the app that declared the permission. Example: `android.permission.ACCESS_DOWNLOAD_MANAGER`

=== IP Networking
. You should use HTTPS over HTTP anywhere that HTTPS is supported on the server, because mobile devices frequently connect on networks that are not secured, such as public Wi-Fi hotspots.
Authenticated, encrypted socket-level communication can be easily implemented using the https://developer.android.com/reference/javax/net/ssl/SSLSocket.html[SSLSocket class].

. Some applications use localhost network ports for handling sensitive IPC.
You should not use this approach because these interfaces are accessible by other applications on the device.
Instead, use an Android IPC mechanism where authentication is possible, such as with a Service.
Binding to `INADDR_ANY` is worse than using loopback because then your application may receive requests from anywhere.

. Make sure that you don't trust data downloaded from HTTP or other insecure protocols. This includes validation of input in WebView and any responses to intents issued against HTTP.

=== Telephony Networking
. Beware that SMS is neither encrypted nor strongly authenticated on either the network or the device. In particular, any SMS receiver should expect that a malicious user may have sent the SMS to your application.
Don't rely on unauthenticated SMS data to perform sensitive commands.

. Also, you should be aware that SMS may be subject to spoofing and/or interception on the network. On the Android-powered device itself, SMS messages are transmitted as broadcast intents, so they may be read or captured by other applications that have the `READ_SMS` permission.

=== Input Validation
. Insufficient input validation is one of the most common security problems affecting applications, regardless of what platform they run on.
Android has platform-level countermeasures that reduce the exposure of applications to input validation issues, and you should use those features where possible.

. If you are using native code, any data read from files, received over the network, or received from an IPC has the potential to introduce a security issue. The most common problems are http://en.wikipedia.org/wiki/Buffer_overflow[buffer overflows], http://en.wikipedia.org/wiki/Double_free#Use_after_free[use after free], and http://en.wikipedia.org/wiki/Off-by-one_error[off-by-one errors].
Android provides a number of technologies like ASLR and DEP that reduce the exploitability of these errors, but they don't solve the underlying problem. You can prevent these vulnerabilities by carefully handling pointers and managing buffers.

. If you are using data within queries that are submitted to an SQL database or a content provider, SQL injection may be an issue. The best defense is to use parameterized queries, as is discussed in the above section about content providers. Limiting permissions to read-only or write-only can also reduce the potential for harm related to SQL injection.

. You should make sure to use well-structured data formats and verify that the data conforms to the expected format. While blacklisting of characters or character-replacement can be an effective strategy, these techniques are error prone in practice and should be avoided when possible.

=== Handling User Data
. In general, the best approach for user data security is to minimize the use of APIs that access sensitive or personal user data. If you have access to user data and can avoid storing or transmitting it, don't store or transmit the data.

. Consider if there is a way that your application logic can be implemented using a hash or non-reversible form of the data.

. For example, your application might use the hash of an email address as a primary key to avoid transmitting or storing the email address. This reduces the chances of inadvertently exposing data, and it also reduces the chance of attackers attempting to exploit your application.

. If your app requires access to sensitive data, evaluate whether you need to transmit it to a server or you can run the operation on the client. Consider running any code using sensitive data on the client to avoid transmitting user data.

. Also, make sure that you do not inadvertently expose user data to other applications on the device through overly permissive IPC, world-writable files, or network sockets. Overly permissive IPC is a special case of leaking permission-protected data.

. If a GUID is required, create a large, unique number and store it. Don't use phone identifiers such as the phone number or IMEI, which may be associated with personal information.

. Be careful when writing to on-device logs. In Android, logs are a shared resource and are available to an application with the `READ_LOGS` permission.

=== Using Webviews
. Because WebView consumes web content that can include HTML and JavaScript, improper use can introduce common web security issues such as XSS.
 Android includes a number of mechanisms to reduce the scope of these potential issues by limiting the capability of WebView to the minimum functionality required by your application

 . If your application doesn't directly use JavaScript within a WebView, do not call `setJavaScriptEnabled()`. By default, WebView does not execute JavaScript, so XSS is not possible.

 . If your application accesses sensitive data with a WebView, you may want to use the `clearCache()` method to delete any files stored locally. You can also use server-side headers such as `no-cache` to indicate that an application should not cache particular content.

. Use `addJavaScriptInterface()` with particular care because it allows JavaScript to invoke operations that are normally reserved for Android applications. If you use it, expose `addJavaScriptInterface()` only to web pages from which all input is trustworthy.
In general, the Android documentation recommends exposing `addJavaScriptInterface()` only to JavaScript that is contained within your application APK.

=== Handling Credentials
. To make phishing attacks more conspicuous and less likely to be successful, minimize the frequency of asking for user credentials. Instead use an authorization token and refresh it.

. Where possible, don't store user names and passwords on the device. Instead, perform initial authentication using the user name and password supplied by the user, and then use a short-lived, service-specific authorization token.

. Services that are accessible to multiple applications should be accessed using AccountManager. If possible, use the AccountManager class to invoke a cloud-based service and don't store passwords on the device.

. After using AccountManager to retrieve an Account, use https://developer.android.com/reference/android/accounts/Account.html#CREATOR[CREATOR] before passing in any credentials so that you do not inadvertently pass credentials to the wrong application.

. If credentials are used only by applications that you create, you can verify the application that accesses the AccountManager using `checkSignature()`. Alternatively, if only one application uses the credential, you might use a KeyStore for storage.

=== Cryptography

. Use a secure random number generator, SecureRandom, to initialize any cryptographic keys generated by KeyGenerator. Use of a key that is not generated with a secure random number generator significantly weakens the strength of the algorithm and may allow offline attacks.

. If you need to store a key for repeated use, use a mechanism, such as KeyStore, that provides a mechanism for long term storage and retrieval of cryptographic keys.

=== IPC
. Some apps attempt to implement IPC using traditional Linux techniques such as network sockets and shared files.
However, you should instead use Android system functionality for IPC such as https://developer.android.com/reference/android/content/Intent.html[Intent], https://developer.android.com/reference/android/os/Binder.html[Binder] or https://developer.android.com/reference/android/os/Messenger.html[Messenger] with a https://developer.android.com/reference/android/app/Service.html[Service], and https://developer.android.com/reference/android/content/BroadcastReceiver.html[BroadcastReceiver].
The Android IPC mechanisms allow you to verify the identity of the application connecting to your IPC and set a security policy for each IPC mechanism.

. Many of the security elements are shared across IPC mechanisms. If your IPC mechanism is not intended for use by other applications, set the `android:exported` attribute to `false` in the component's manifest element.

. If your IPC is accessible to other applications, you can apply a security policy by using the `<permission>` element.
If IPC is between your own separate apps that are signed with the same key, it is preferable to use signature level permission in the `android:protectionLevel`.

=== Intents
. For activities and broadcast receivers, intents are the preferred mechanism for asynchronous IPC in Android. Depending on your application requirements, you might use https://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)[sendBroadcast()], https://developer.android.com/reference/android/content/Context.html#sendOrderedBroadcast[sendOrderedBroadcast()], or an explicit intent to a specific application component. For security purposes, explicit intents are preferred.

. If you use an intent to bind to a Service, ensure that your app is secure by using an explicit intent. Using an implicit intent to start a service is a security hazard because you can't be certain what service will respond to the intent, and the user can't see which service starts.

. Senders of an intent can verify that the recipient has permission by specifying a non-null permission with the method call. Only applications with that permission receive the intent. If data within a broadcast intent may be sensitive, you should consider applying a permission to make sure that malicious applications can't register to receive those messages without appropriate permissions. In those circumstances, you may also consider invoking the receiver directly, rather than raising a broadcast.

=== Services
A Service is often used to supply functionality for other applications to use. Each service class must have a corresponding `<service>` declaration in its manifest file.

. By default, services are not exported and cannot be invoked by any other application. However, if you add any intent filters to the service declaration, it is exported by default.
It's best if you explicitly declare the `android:exported` attribute to be sure it behaves as you'd like. Services can also be protected using the `android:permission attribute`.
By doing so, other applications need to declare a corresponding `<uses-permission>` element in their own manifest to be able to start, stop, or bind to the service.

. If your app targets Android 5.0 (API level 21) or later, you should use the https://developer.android.com/reference/android/app/job/JobScheduler.html[JobScheduler] to execute background services.

. A service can protect individual IPC calls into it with permissions, by calling `checkCallingPermission()` before executing the implementation of that call.
You should use the declarative permissions in the manifest, since those are less prone to oversight.

=== Binder and Messenger Interfaces
. Using https://developer.android.com/reference/android/os/Binder.html[Binder] or https://developer.android.com/reference/android/os/Messenger.html[Messenger] is the preferred mechanism for RPC-style IPC in Android.
They provide a well-defined interface that enables mutual authentication of the endpoints, if required.

. If you are providing an interface that does require access controls, use https://developer.android.com/reference/android/content/Context.html#checkCallingPermission(java.lang.String)[checkCallingPermission()] to verify whether the caller has a required permission.
This is especially important before accessing a service on behalf of the caller, as the identify of your application is passed to other interfaces.

=== Broadcast Receivers
. A BroadcastReceiver handles asynchronous requests initiated by an Intent.

. By default, receivers are exported and can be invoked by any other application. If your BroadcastReceiver is intended for use by other applications, you may want to apply security permissions to receivers using the `<receiver>` element within the application manifest.
This prevents applications without appropriate permissions from sending an intent to the BroadcastReceiver.

=== Dynamically Loading Code
. Loading code from outside of your application APK significantly increases the likelihood of application compromise due to code injection or code tampering.

. If your application does dynamically load code, the most important thing to keep in mind about dynamically-loaded code is that it runs with the same security permissions as the application APK.

. The major security risk associated with dynamically loading code is that the code needs to come from a verifiable source.

=== Virtual Machine Security
. Dalvik is Android's runtime virtual machine (VM). Your application runs in a secure sandbox environment, so other processes on the system can't access your code or private data.

== Security with HTTPS and SSL
. The Secure Sockets Layer (SSL)—now technically known as Transport Layer Security (TLS)—is a common building block for encrypted communications between clients and servers.
It's possible that an application might use SSL incorrectly such that malicious entities may be able to intercept an app's data over the network.

. As of Android 4.2 (Jelly Bean), Android currently contains over 100 CAs that are updated in each release. Similar to a server, a CA has a certificate and a private key. When issuing a certificate for a server, the CA signs the server certificate using its private key. The client can then verify that the server has a certificate issued by a CA known to the platform.

=== HTTPS Example
Assuming you have a web server with a certificate issued by a well known CA, you can make a secure request with code as simple this:

```
URL url = new URL("https://wikipedia.org");
URLConnection urlConnection = url.openConnection();
InputStream in = urlConnection.getInputStream();
copyInputStreamToOutputStream(in, System.out);
```

Suppose instead of receiving the content from `getInputStream()`, it throws an exception:

```
javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.
```

This can happen for several reasons, including:

* *Unknown CA* - The CA that issued the server certificate was unknown.
** In this case, the `SSLHandshakeException` occurs because you have a CA that isn't trusted by the system. It could be because you have a certificate from a new CA that isn't yet trusted by Android or your app is running on an older version without the CA. More often a CA is unknown because it isn't a public CA, but a private one issued by an organization such as a government, corporation, or education institution for their own use. With a custom TrustManager that knows about your CAs, the system is able to validate that your server certificate come from a trusted issuer.
* *Self-Signed Server Certificate* - The server certificate wasn't signed by a CA, but was self signed.
** The second case of `SSLHandshakeException` is due to a self-signed certificate, which means the server is behaving as its own CA. As before, you can create your own TrustManager, this time trusting the server certificate directly.
* *Missing Intermediate CA* - The server configuration is missing an intermediate CA.
** The third case of `SSLHandshakeException` occurs due to a missing intermediate CA. Most public CAs don't sign server certificates directly. Instead, they use their main CA certificate, referred to as the root CA, to sign intermediate CAs. They do this so the root CA can be stored offline to reduce risk of compromise.
** However, operating systems like Android typically trust only root CAs directly, which leaves a short gap of trust between the server certificate—signed by the intermediate CA—and the certificate verifier, which knows the root CA.
** To solve this, the server doesn't send the client only it's certificate during the SSL handshake, but a chain of certificates from the server CA through any intermediates necessary to reach a trusted root CA.
** There are two approaches to solve this issue:
*** Configure the server to include the intermediate CA in the server chain. Most CAs provide documentation on how to do this for all common web servers. This is the only approach if you need the site to work with default Android browsers at least through Android 4.2.
*** Or, treat the intermediate CA like any other unknown CA, and create a TrustManager to trust it directly, as done in the previous two sections.

== Hostname verification
There are two key parts to verifying an SSL connection:

. The first is to verify the certificate is from a trusted source, which was the focus of the previous section.
. The second part is making sure the server you are talking to presents the right certificate. When it doesn't, you'll typically see an error like this:

```
java.io.IOException: Hostname 'example.com' was not verified
at libcore.net.http.HttpConnection.verifySecureSocketHostname(HttpConnection.java:223)
at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:446)
```

* One reason this can happen is due to a server configuration error.
The server is configured with a certificate that does not have a subject or subject alternative name fields that match the server you are trying to reach. It is possible to have one certificate be used with many different servers.

== Warnings About Using SSLSocket Directly
. https://developer.android.com/reference/javax/net/ssl/SSLSocket.html[SSLSocket] does not perform hostname verification. It is up the your app to do its own hostname verification, preferably by calling `getDefaultHostnameVerifier()` with the expected hostname. Further beware that `HostnameVerifier.verify()` doesn't throw an exception on error but instead returns a boolean result that you must explicitly check.

== Blacklisting
. SSL relies heavily on CAs to issue certificates to only the properly verified owners of servers and domains. In rare cases, CAs are either tricked or breached, resulting in the certificates for a hostname to be issued to someone other than the owner of the server or domain.

. In order to mitigate this risk, Android has the ability to blacklist certain certificates or even whole CAs. While this list was historically built into the operating system, starting in Android 4.2 this list can be remotely updated to deal with future compromises.

== Pinning
. An app can further protect itself from fraudulently issued certificates by a technique known as pinning. This prevents the compromise of one of the other 100+ CAs in the system from resulting in a breach of the apps secure channel.

== Client Certificates
. SSL also supports the notion of client certificates that allow the server to validate the identity of a client.

== Nogotofail: A Network Traffic Security Testing Tool
. https://github.com/google/nogotofail[Nogotofail] is a tool gives you an easy way to confirm that your apps are safe against known TLS/SSL vulnerabilities and misconfigurations. 
It's an automated, powerful, and scalable tool for testing network security issues on any device whose network traffic could be made to go through it.

Nogotofail is useful for three main use cases:

* Finding bugs and vulnerabilities.
* Verifying fixes and watching for regressions.
* Understanding what applications and devices are generating what traffic.